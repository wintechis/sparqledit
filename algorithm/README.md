# SPARQL_edit Algorithm

The algorithm for the SPARQL_edit project.


## Algorithm

Inputs:
* (wildcard) SPARQL/Select query
* Query results
* User input information

Output: SPARQL/Update query
* Delete-Insert-Where query for changing a literal value or
* Insert-Where query for inserting a missing literal

Procedure:
1. analyse the edited literal (in the results)
    1. collect information about the edited literal (= variable in query)
    2. find triple pattern with edited variable (in object position)
2. rebuild the original query's where block: replace all (named) variables in bgp statements with named nodes (URIs) or literals from query results
    1. collect all BGP and relevant 'OPTIONAL' patterns
    2. if subject, predicate or object is a (named) variable, replace with cell value from result table's row where literal was modified
    3. if subject, predicate or object is blank node, replace with variable (reasons: [1.1](https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#BlankNodesInResults), [1.2](https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#BGPsparqlBNodes), [2](https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#grammarBNodes))
3. build the update query ([delete-insert-where](https://www.w3.org/TR/sparql11-update/#deleteInsert))
    1. copy prefixes
    2. copy modified where block from (2.)
    3. create 'DELETE' and 'INSERT' templates based on (2.)
    4. copy the specified default graph ('FROM' -> 'WITH')

### Pseudocode:
```
function viewUpdateToSPARQLUpdate(selectQuery, mu_ed, l_new):
	literalInfo = analyseEditedLiteral(mu_ed)
	bgpogp = copyBasicAndOptionalGraphPatterns(selectQuery)
	editedPattern = findTriplePatternWithEditedVariable(bgpogp, literalInfo)
	bgpogpReplaced = replaceVariablesWithRDFTerms(bgpogp, mu_ed)
	updateQuery = constructUpdateQuery(selectQuery, bgpogpReplaced, editedPattern, mu_ed, l_new)
	return updateQuery

function constructUpdateQuery(selectQuery, bgpogpReplaced, editedPattern, mu_ed, l_new)
	insertTemplate = buildInsertTemplate(editedPattern, mu_ed, l_new)
	deleteTemplate = buildInsertTemplate(editedPattern, mu_ed)
	prefixesAndGraphInfo = extractPrefixesAndGraphInfo(selectQuery)
	updateQuery = assembleUpdateQuery(insertTemplate, deleteTemplate, bgpogpReplaced, prefixesAndGraphInfo)
	return updateQuery
```

### Example
SPARQL/Select query for patient information:
```
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX schema: <http://schema.org/>
SELECT ?name ?family ?birthdate ?weight
FROM <http://localhost:3030/example/graph1>
WHERE {
  ?patient a schema:Patient ;
    foaf:name ?name .
  OPTIONAL {  
    ?patient foaf:familyName ?family . 
  }
  ?patient schema:birthDate ?birthdate .
  OPTIONAL {
    ?patient schema:weight [
      a schema:QuantitativeValue ;
      schema:value ?weight
    ] .
  }
}
```
Autogenerated SPARQL/Update query for changing the patient's weight value:
```
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX schema: <http://schema.org/>
WITH <http://localhost:3030/example/graph1>
DELETE { ?g_1 schema:value "80.5"^^<http://www.w3.org/2001/XMLSchema#decimal>. }
INSERT { ?g_1 schema:value "86"^^<http://www.w3.org/2001/XMLSchema#decimal>. }
WHERE {
  <http://example.org/patient/1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> schema:Patient;
    foaf:name "John Doe".
  <http://example.org/patient/1> schema:birthDate "1990-10-22"^^<http://www.w3.org/2001/XMLSchema#date>.
  <http://example.org/patient/1> schema:weight ?g_1.
  ?g_1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> schema:QuantitativeValue;
    schema:value "80.5"^^<http://www.w3.org/2001/XMLSchema#decimal>.
}
```

### Insert mode

The algorithm is capable of generating SPARQL/Update queries for inserting missing literals if two conditions are fulfilled:
1. The edited variable must be defined inside an optional graph pattern (OGP). Otherwise, it would not be a solution to the SPARQL/Select query.
2. The SPARQL/Select query must include at least one RDF literal result for the edited variable. This literal result is used as a template for a new literal value.

The insert mode is a special case for the algorithm. If the OGP is composed of an [n-ary relation](https://www.w3.org/TR/2006/NOTE-swbp-n-aryRelations-20060412/), the INSERT template has to include all successive triples needed for the construction of a new blank with the user-defined literal.


## Developer info

The SPARQL_edit algorithm is implemented in TypeScript. The build in `dist` is used by the [SPARQL_edit application](../app/README.md).

### Setup

Transpile with TSC: 
1. `npm i`
2. `npm run build` or `tsc`

Run tests: `npm t`

### Dependencies

The SPARQL_edit algorithm relies on [SPARQL.js](https://github.com/RubenVerborgh/SPARQL.js) for working with SPARQL queries as in TypeScript/JavaScript. SPARQL.js can parse Sparql query strings into TS/JS objects and back into strings. The SPARQL_edit algorithm uses and extends the types and object structure from SPARQL.js to analyse the original query and build the new update query object.

It uses [rdf-data-factory.js](https://github.com/rubensworks/rdf-data-factory.js) as an implementation for the [RDF/JS DataFactory](http://rdf.js.org/data-model-spec/#datafactory-interface) to create new instances of RDF terms (literals, blank nodes or variables).

### Tests

The testing framework [Jest](https://jestjs.io/) is used for integration tests. There are two test cases that are made up of a SPARQL/Select query, example results and different update or insert queries for the validation of different tasks. There is one invented example with [schema.org](https://schema.org/) classes and an example based on the [Nobel Prizes as Linked Data](https://data.nobelprize.org/specification/) dataset.

### API

```typescript
buildUpdateQuery(selectQueryObject: SparqlJS.SelectQuery, sparqlEditResultRow: SparqlEditResultBindings): SparqlJS.Update
```

The exposed 'buildUpdateQuery' function expects two arguments:
* the SPARQL/Select query as _SparqlJS.SelectQuery_ object
* the SPARQL result bindings of type _SparqlEditResultBindings_, an extension of _SparqlResultBindings_
  * case 'modified literal': one RDF.Literal has a 'valueNew' property
  * case 'literal for insertion': one RDF.Literal has both 'valueNew' and 'insertMode' properties

Example of a _SparqlEditResultBindings_ object where a result value for the 'name' variable was changed:
```json
[
  {
    "name": {
      "termType": "Literal",
      "value": "John Doe",
      "language": "",
      "datatype": {
        "termType": "NamedNode",
        "value": "http://www.w3.org/2001/XMLSchema#string"
      },
      "valueNew": "John Doe NEW"
    },
    "birthdate": {...},
    "weight": {...}
  },
  {
    "name": {...},
    "birthdate": {...},
    "weight": {...}
  },
  ...
]
```

```typescript
buildUpdateCheckQuery(selectQueryObject: SparqlJS.SelectQuery, sparqlEditResultRow: SparqlEditResultBindings): SparqlJS.SelectQuery
```

The exposed 'buildUpdateCheckQuery' function expects the same arguments but produces a SPARQL/Select query which is used for checking if a generated update query would work as expected. 
The SPARQL_edit application is able to decide if it is safe to execute the SPARQL/Update query based on the number of solutions for this check query:
* 0 results: relevant triples in the graph have been changed in the meantime
* 1 result: ideal case in which the update query would affect exactly one RDF triple
* 2..n results: the update query is ambiguous and would alter more than one RDF triple; unlikely special case with blank nodes